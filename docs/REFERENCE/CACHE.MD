## ğŸ§¹ Sistema de Cache com AsyncStorage

O projeto utiliza um **sistema de cache** baseado em `AsyncStorage` para:

- **Reduzir requisiÃ§Ãµes** ao Firestore.
- Melhorar a **performance** percebida pelo usuÃ¡rio.
- Permitir um funcionamento mais **resiliente offline**.

Toda a lÃ³gica de cache fica isolada na camada `core/cache`.

---

## ğŸ—‚ï¸ Estrutura de Pastas

```bash
src/
â””â”€â”€ core/
    â””â”€â”€ cache/
        â”œâ”€â”€ cacheService.ts # ServiÃ§o principal de cache (wrapper de AsyncStorage)
        â”œâ”€â”€ cacheConfig.ts  # ConfiguraÃ§Ãµes de TTL e polÃ­ticas de expiraÃ§Ã£o
        â”œâ”€â”€ cacheKeys.ts    # GeraÃ§Ã£o padronizada de chaves
        â”œâ”€â”€ types.ts        # Tipos e interfaces relacionados ao cache
        â””â”€â”€ index.ts        # Re-exportaÃ§Ãµes
```

---

## âš™ï¸ EstratÃ©gias de Cache

### 1. Cache-First com Stale-While-Revalidate (SWR)

Fluxo adotado em operaÃ§Ãµes de leitura, principalmente em transaÃ§Ãµes:

1. **Busca no cache** primeiro.
2. **Retorna imediatamente** o valor em cache (se existir).
3. Em paralelo, dispara uma **requisiÃ§Ã£o ao Firestore**.
4. Quando chegam dados novos:
   - Atualiza o cache.
   - Atualiza o estado (Zustand) e, consequentemente, a UI.

Vantagens:
- Resposta instantÃ¢nea para listas grandes.
- Dados atualizados assim que possÃ­vel, sem travar a UI.

### 2. Fallback Offline

- Se a requisiÃ§Ã£o ao Firestore falhar (sem internet, timeout, etc.):
  - O sistema tenta usar o **cache mesmo expirado**.
  - Isso garante que o usuÃ¡rio continue enxergando dados, ainda que desatualizados.

---

## â±ï¸ ConfiguraÃ§Ã£o de TTL

Os tempos de vida (TTL) sÃ£o configurados em `cacheConfig.ts` por tipo de dado:

- **TransaÃ§Ãµes**: 5 minutos â€“ dados dinÃ¢micos, atualizam com frequÃªncia.
- **Resumo Financeiro**: 2 minutos â€“ altamente dinÃ¢mico, usado em dashboards.
- **Resumos Mensais**: 10 minutos â€“ dados mais estÃ¡veis.
- **TransaÃ§Ã£o Individual**: 5 minutos.
- **Dados do UsuÃ¡rio**: 15 minutos.

Cada entrada de cache guarda:
- O **payload** (dados).
- O **timestamp** de criaÃ§Ã£o/atualizaÃ§Ã£o.
- O **TTL**.

---

## ğŸ”— IntegraÃ§Ã£o com Stores (Zustand)

O cache Ã© utilizado principalmente pelo `transactionStore`:

- `fetchTransactions()` â€“ lista de transaÃ§Ãµes.
- `fetchSummary()` â€“ resumo financeiro.
- `fetchMonthlySummaries()` â€“ grÃ¡ficos mensais.
- `getTransactionById()` â€“ transaÃ§Ã£o especÃ­fica.
- `createTransaction()` â€“ **invalida/atualiza** entradas relevantes.
- `deleteAllTransactions()` â€“ **limpa** cache relacionado ao usuÃ¡rio.

Para detalhes sobre como o estado Ã© gerenciado, veja **`STATE_MANAGEMENT.MD`**.

---

## ğŸ§¹ Limpeza e InvalidaÃ§Ã£o de Cache

O sistema implementa trÃªs formas principais de limpeza:

- **AutomÃ¡tica**
  - Entradas expiradas sÃ£o removidas/ignoradas automaticamente ao serem lidas.

- **No Logout**
  - Ao sair da conta, todo cache relacionado ao usuÃ¡rio Ã© removido (`clearUserCache(userId)`).

- **Manual / EspecÃ­fica**
  - OperaÃ§Ãµes sensÃ­veis, como `createTransaction()` ou `deleteAllTransactions()`, disparam invalidaÃ§Ãµes especÃ­ficas:
    - Limpeza de listas de transaÃ§Ãµes.
    - Limpeza de resumos e grÃ¡ficos.

---

## ğŸ§ª Boas PrÃ¡ticas Adotadas

- **Chaves padronizadas** via `cacheKeys.ts` para evitar colisÃµes e strings mÃ¡gicas.
- Toda lÃ³gica de acesso a `AsyncStorage` centralizada em `cacheService.ts`.
- Nenhum componente/tela acessa `AsyncStorage` diretamente.
- Uso consistente de TTL configurado em um Ãºnico lugar (`cacheConfig.ts`).

---